\section{Entry criteria}
Before proceeding with the integration test in this section we analysed the prerequisites that the software must satisfy.
\\First of all we must have a code-complete project, all modules must be available and their performances and memory requirements have to fit the specifications.
\\Secondly all the modules must be unit tested. 
\\Finally the RASD and DD must be completed, they provide all the documentation that we need for proceeding in the succeeding steps.

\section{Elements to be integrated}
In the Design Document, we identified four main Tiers: the EIS Tier, the Business Tier, the Web Tier and the Client Tier. These are the subsystems that we must integrate in this section.
\\The Enterprise Information System Tier is composed principally by a DBMS that has to be integrated while in the Business Tier all the system components have to be tested individually before to be integrated. The Web Tier relates to the Client Tier and the Business Tier and both the interfaces have to be integrated. Finally, the Client Tier is composed by the On-Board computer, the Mobile application and Web application; they have to be tested individually and then they have to be integrated with their respective Tier. 

\section{Integration testing strategy}
We choose for our integration testing strategy to adopt a bottom-up approach. In this way, we test the subsystems from the lower level to the top level, where all the modules are integrated. 
\\There are different advantages following this strategy. The test conditions for each module are easier to create and the test results can be analysed in a simpler way. Then it's easier to localize problems and faults. In the end we can proceed with the test phase of our subsystems alongside their implementation.
\\On the other side the bottom-up approach brings some disadvantages. The main one is the need of driver programs in order to simulate the missing modules while they aren't already deployed. Another point is the fact that we can't test the whole program until the last module has been developed. Anyway, we think that these disadvantages are bearable comparing the advantages that this approach provides, a last evidence is the fact that probably almost all the faults occurs toward the bottom of the system.
\\In the testing phase we also selected the order of the subsystems to analyse, not randomly but privileging the critical ones.
\\ We also follow a specific path before performing the integration test. First of all, we design the integration test and the specific drivers if they aren't already done. If it was not made at the unit test we design the input test data, thirdly we set the modules involved, the drivers and the input test data. Finally, we proceed performing the integration test.

\section{Sequence of Component/Function Integration}
NOTE: The structure of this section may vary depending on the integration strategy you select in Section 2.3. Use the structure proposed below as a non mandatory guide.

	\subsection{Software Integration Sequence}
	Identify the sequence in which the software components will be integrated within the subsystem. Relate this sequence to any product features/functions that are being built up.
	\subsection{Subsystem Integration Sequence}
	Identify the order in which subsystems will be integrated.

If you have a single subsystem, 2.4.1 and 2.4.2 are to be merged in a single section. You can refer to Section 2.2 of the test plan example [1] as an example of what we expect.
